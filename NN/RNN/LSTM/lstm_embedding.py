# -*- coding: utf-8 -*-
"""LSTM-embedding.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1up_JyJBZ1VnlidzHKtpGMGMRc1W9uXG5
"""

import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import tensorflow as tf
from tensorflow import keras
import sklearn 
import os
import sys
import time

print(tf.__version__)
print(sys.version_info)
for module in mpl,np,pd,sklearn,tf,keras:
  print(module.__name__,module.__version__)

imdb=keras.datasets.imdb
vocab_size=10000
index_from=3
(train_data,train_labels),(test_data,test_labels)=imdb.load_data(num_words=vocab_size,index_from=index_from)

word_index=imdb.get_word_index()
print(len(word_index))

word_index={k:(v+3) for k,v in word_index.items()}

word_index['<PAD>']=0
word_index['<START>']=1
word_index['<UNK>']=2
word_index['<END>']=3

reverse_word_index=dict([
    (value,key) for key,value in word_index.items()
])

def decode_review(text_ids):
    return ' '.join([reverse_word_index.get(word_id,'<UNK>') for word_id in text_ids])

decode_review(train_data[0])

max_length=500

train_data=keras.preprocessing.sequence.pad_sequences(
    train_data,value=word_index['<PAD>'],
    padding='post',maxlen=max_length
)

test_data=keras.preprocessing.sequence.pad_sequences(
    test_data,value=word_index['<PAD>'],
    padding='post',maxlen=max_length
)

print(train_data[0])

# 单向LSTM

embedding_dim=16
batch_size=512
# 把DNN的全局平均换成单向RNN，时间变长，不断修改效果变好
# return_sequences:Boolean. Whether to return the last output in the output sequence, or the full sequence 文本生成、机器翻译是要返回所有序列的True,只要最后一个序列False
# 这里的变量名字应该改成model_LSTM的（代码从单向RNN复制过来正在训练，就不改了）
single_rnn_model=keras.models.Sequential([
          keras.layers.Embedding(vocab_size,embedding_dim,input_length=max_length),
          keras.layers.LSTM(units=64,return_sequences=False),
          # w=64,b=64
          keras.layers.Dense(64,activation='relu'),
          keras.layers.Dense(1,activation='sigmoid'),
])

single_rnn_model.summary()
single_rnn_model.compile(optimizer='adam',loss='binary_crossentropy',metrics=['accuracy'])

# 全连接层参数是4160 wx+b:x是一维的64

history_single_rnn=single_rnn_model.fit(
    train_data,train_labels,
    epochs=30,
    batch_size=batch_size,
    validation_split=0.2
)

def plot_learning_curves(history,label,epochs,min_value,max_value):
  data={}
  data[label]=history.history[label]
  data['val_'+label]=history.history['val_'+label]
  pd.DataFrame(data).plot(figsize=(8,5))
  plt.grid(True)
  plt.axis([0,epochs,min_value,max_value])
  plt.show()


# 训练集、验证集上的准确率
plot_learning_curves(history_single_rnn,'accuracy',30,0,1)
# 训练集、验证集上的损失
plot_learning_curves(history_single_rnn,'loss',30,0,1)

"""过拟合-验证集上效果差一些"""

single_rnn_model.evaluate(
    test_data,test_labels,
    batch_size=batch_size,
    verbose=0
)

# 双向双层LSTM
embedding_dim=16
batch_size=512

# return_sequences:Boolean. Whether to return the last output in the output sequence, or the full sequence 文本生成、机器翻译是要返回所有序列的True,只要最后一个序列False
model=keras.models.Sequential([
          keras.layers.Embedding(vocab_size,embedding_dim,input_length=max_length),
          keras.layers.Bidirectional(keras.layers.LSTM(units=64,return_sequences=True)),
          keras.layers.Bidirectional(keras.layers.LSTM(units=64,return_sequences=False)),
          # w=64,b=64
          keras.layers.Dense(64,activation='relu'),
          keras.layers.Dense(1,activation='sigmoid'),
])

model.summary()
model.compile(optimizer='adam',loss='binary_crossentropy',metrics=['accuracy'])

# 全连接层参数是4160 wx+b:x是一维的64

history=single_rnn_model.fit(
    train_data,train_labels,
    epochs=30,
    batch_size=batch_size,
    validation_split=0.2
)

# 训练集、验证集上的准确率
plot_learning_curves(history,'accuracy',30,0,1)
# 训练集、验证集上的损失
plot_learning_curves(history,'loss',30,0,1)

# 双向单层LSTM

embedding_dim=16
batch_size=512

# return_sequences:Boolean. Whether to return the last output in the output sequence, or the full sequence 文本生成、机器翻译是要返回所有序列的True,只要最后一个序列False
bi_lstm_model=keras.models.Sequential([
          keras.layers.Embedding(vocab_size,embedding_dim,input_length=max_length),
           keras.layers.Bidirectional(keras.layers.LSTM(units=32,return_sequences=False)),
          # w=64,b=64
          keras.layers.Dense(64,activation='relu'),
          keras.layers.Dense(1,activation='sigmoid'),
])

bi_lstm_model.summary()
bi_lstm_model.compile(optimizer='adam',loss='binary_crossentropy',metrics=['accuracy'])

# 全连接层参数是4160 wx+b:x是一维的64

history=bi_lstm_model.fit(
    train_data,train_labels,
    epochs=30,
    batch_size=batch_size,
    validation_split=0.2
)

# 训练集、验证集上的准确率
plot_learning_curves(history,'accuracy',30,0,1)
# 训练集、验证集上的损失
plot_learning_curves(history,'loss',30,0,1)

bi_lstm_model.evaluate(test_data,test_labels,batch_size=batch_size,verbose=0)